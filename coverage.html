
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>controllers: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/russ/kogaro/internal/controllers/validation_controller.go (0.0%)</option>
				
				<option value="file1">github.com/russ/kogaro/internal/validators/reference_validator.go (0.0%)</option>
				
				<option value="file2">github.com/russ/kogaro/main.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package controllers

import (
        "context"
        "time"

        "github.com/go-logr/logr"
        "k8s.io/apimachinery/pkg/runtime"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/client"

        "github.com/russ/kogaro/internal/validators"
)

type ValidationController struct {
        Client       client.Client
        Scheme       *runtime.Scheme
        Log          logr.Logger
        Validator    *validators.ReferenceValidator
        ScanInterval time.Duration
}

func (r *ValidationController) SetupWithManager(mgr ctrl.Manager) error <span class="cov0" title="0">{
        // Start the periodic validation as a runnable
        return mgr.Add(r)
}</span>

func (r *ValidationController) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) <span class="cov0" title="0">{
        log := r.Log.WithValues("validation", req.NamespacedName)

        // Run the validation scan
        log.Info("starting cluster validation scan")
        
        if err := r.Validator.ValidateCluster(ctx); err != nil </span><span class="cov0" title="0">{
                log.Error(err, "failed to validate cluster")
                return ctrl.Result{RequeueAfter: r.ScanInterval}, err
        }</span>

        <span class="cov0" title="0">log.Info("cluster validation scan completed successfully")
        
        // Requeue after the scan interval
        return ctrl.Result{RequeueAfter: r.ScanInterval}, nil</span>
}

// Start begins the periodic validation process
func (r *ValidationController) Start(ctx context.Context) error <span class="cov0" title="0">{
        log := r.Log.WithName("periodic-validator")
        
        ticker := time.NewTicker(r.ScanInterval)
        defer ticker.Stop()

        // Run initial validation
        log.Info("running initial cluster validation")
        if err := r.Validator.ValidateCluster(ctx); err != nil </span><span class="cov0" title="0">{
                log.Error(err, "initial validation failed")
        }</span>

        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        log.Info("stopping periodic validation")
                        return nil</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        log.Info("running periodic cluster validation")
                        if err := r.Validator.ValidateCluster(ctx); err != nil </span><span class="cov0" title="0">{
                                log.Error(err, "periodic validation failed")
                        }</span>
                }
        }
}</pre>
		
		<pre class="file" id="file1" style="display: none">package validators

import (
        "context"
        "fmt"

        "github.com/go-logr/logr"
        networkingv1 "k8s.io/api/networking/v1"
        corev1 "k8s.io/api/core/v1"
        storagev1 "k8s.io/api/storage/v1"
        "k8s.io/apimachinery/pkg/types"
        "sigs.k8s.io/controller-runtime/pkg/client"
        "github.com/prometheus/client_golang/prometheus"
        "github.com/prometheus/client_golang/prometheus/promauto"
)

var (
        validationErrors = promauto.NewCounterVec(
                prometheus.CounterOpts{
                        Name: "kogaro_validation_errors_total",
                        Help: "Total number of validation errors found",
                },
                []string{"resource_type", "validation_type", "namespace"},
        )
        
        validationRuns = promauto.NewCounter(
                prometheus.CounterOpts{
                        Name: "kogaro_validation_runs_total",
                        Help: "Total number of validation runs performed",
                },
        )
)

type ValidationError struct {
        ResourceType   string
        ResourceName   string
        Namespace      string
        ValidationType string
        Message        string
}

type ValidationConfig struct {
        EnableIngressValidation     bool
        EnableConfigMapValidation   bool
        EnableSecretValidation      bool
        EnablePVCValidation         bool
        EnableServiceAccountValidation bool
}

type ReferenceValidator struct {
        client client.Client
        log    logr.Logger
        config ValidationConfig
}

func NewReferenceValidator(client client.Client, log logr.Logger, config ValidationConfig) *ReferenceValidator <span class="cov0" title="0">{
        return &amp;ReferenceValidator{
                client: client,
                log:    log.WithName("reference-validator"),
                config: config,
        }
}</span>

func (v *ReferenceValidator) ValidateCluster(ctx context.Context) error <span class="cov0" title="0">{
        validationRuns.Inc()
        
        var allErrors []ValidationError

        // Validate Ingress references
        if v.config.EnableIngressValidation </span><span class="cov0" title="0">{
                ingressErrors, err := v.validateIngressReferences(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to validate ingress references: %w", err)
                }</span>
                <span class="cov0" title="0">allErrors = append(allErrors, ingressErrors...)</span>
        }

        // Validate ConfigMap references
        <span class="cov0" title="0">if v.config.EnableConfigMapValidation </span><span class="cov0" title="0">{
                configMapErrors, err := v.validateConfigMapReferences(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to validate configmap references: %w", err)
                }</span>
                <span class="cov0" title="0">allErrors = append(allErrors, configMapErrors...)</span>
        }

        // Validate Secret references
        <span class="cov0" title="0">if v.config.EnableSecretValidation </span><span class="cov0" title="0">{
                secretErrors, err := v.validateSecretReferences(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to validate secret references: %w", err)
                }</span>
                <span class="cov0" title="0">allErrors = append(allErrors, secretErrors...)</span>
        }

        // Validate PVC references
        <span class="cov0" title="0">if v.config.EnablePVCValidation </span><span class="cov0" title="0">{
                pvcErrors, err := v.validatePVCReferences(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to validate pvc references: %w", err)
                }</span>
                <span class="cov0" title="0">allErrors = append(allErrors, pvcErrors...)</span>
        }

        // Validate ServiceAccount references
        <span class="cov0" title="0">if v.config.EnableServiceAccountValidation </span><span class="cov0" title="0">{
                saErrors, err := v.validateServiceAccountReferences(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to validate serviceaccount references: %w", err)
                }</span>
                <span class="cov0" title="0">allErrors = append(allErrors, saErrors...)</span>
        }

        // Log all validation errors
        <span class="cov0" title="0">for _, validationErr := range allErrors </span><span class="cov0" title="0">{
                v.log.Info("validation error found",
                        "resource_type", validationErr.ResourceType,
                        "resource_name", validationErr.ResourceName,
                        "namespace", validationErr.Namespace,
                        "validation_type", validationErr.ValidationType,
                        "message", validationErr.Message,
                )
                
                validationErrors.WithLabelValues(
                        validationErr.ResourceType,
                        validationErr.ValidationType,
                        validationErr.Namespace,
                ).Inc()
        }</span>

        <span class="cov0" title="0">v.log.Info("cluster validation completed", "total_errors", len(allErrors))
        return nil</span>
}

func (v *ReferenceValidator) validateIngressReferences(ctx context.Context) ([]ValidationError, error) <span class="cov0" title="0">{
        var errors []ValidationError

        // Get all Ingresses
        var ingresses networkingv1.IngressList
        if err := v.client.List(ctx, &amp;ingresses); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list ingresses: %w", err)
        }</span>

        // Get all IngressClasses for validation
        <span class="cov0" title="0">var ingressClasses networkingv1.IngressClassList
        if err := v.client.List(ctx, &amp;ingressClasses); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list ingress classes: %w", err)
        }</span>

        // Build a map of existing IngressClass names
        <span class="cov0" title="0">existingClasses := make(map[string]bool)
        for _, ic := range ingressClasses.Items </span><span class="cov0" title="0">{
                existingClasses[ic.Name] = true
        }</span>

        // Validate each Ingress
        <span class="cov0" title="0">for _, ingress := range ingresses.Items </span><span class="cov0" title="0">{
                if ingress.Spec.IngressClassName != nil </span><span class="cov0" title="0">{
                        className := *ingress.Spec.IngressClassName
                        if !existingClasses[className] </span><span class="cov0" title="0">{
                                errors = append(errors, ValidationError{
                                        ResourceType:   "Ingress",
                                        ResourceName:   ingress.Name,
                                        Namespace:      ingress.Namespace,
                                        ValidationType: "dangling_ingress_class",
                                        Message:        fmt.Sprintf("IngressClass '%s' does not exist", className),
                                })
                        }</span>
                }

                // Validate Service references in Ingress rules
                <span class="cov0" title="0">for _, rule := range ingress.Spec.Rules </span><span class="cov0" title="0">{
                        if rule.HTTP != nil </span><span class="cov0" title="0">{
                                for _, path := range rule.HTTP.Paths </span><span class="cov0" title="0">{
                                        serviceName := path.Backend.Service.Name
                                        
                                        // Check if the service exists
                                        var service corev1.Service
                                        err := v.client.Get(ctx, types.NamespacedName{
                                                Name:      serviceName,
                                                Namespace: ingress.Namespace,
                                        }, &amp;service)
                                        
                                        if err != nil </span><span class="cov0" title="0">{
                                                errors = append(errors, ValidationError{
                                                        ResourceType:   "Ingress",
                                                        ResourceName:   ingress.Name,
                                                        Namespace:      ingress.Namespace,
                                                        ValidationType: "dangling_service_reference",
                                                        Message:        fmt.Sprintf("Service '%s' referenced in Ingress does not exist", serviceName),
                                                })
                                        }</span>
                                }
                        }
                }
        }

        <span class="cov0" title="0">return errors, nil</span>
}

func (v *ReferenceValidator) validateConfigMapReferences(ctx context.Context) ([]ValidationError, error) <span class="cov0" title="0">{
        var errors []ValidationError

        // Get all Pods to check ConfigMap references
        var pods corev1.PodList
        if err := v.client.List(ctx, &amp;pods); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list pods: %w", err)
        }</span>

        <span class="cov0" title="0">for _, pod := range pods.Items </span><span class="cov0" title="0">{
                // Check ConfigMap references in volumes
                for _, volume := range pod.Spec.Volumes </span><span class="cov0" title="0">{
                        if volume.ConfigMap != nil </span><span class="cov0" title="0">{
                                configMapName := volume.ConfigMap.Name
                                if err := v.validateConfigMapExists(ctx, configMapName, pod.Namespace); err != nil </span><span class="cov0" title="0">{
                                        errors = append(errors, ValidationError{
                                                ResourceType:   "Pod",
                                                ResourceName:   pod.Name,
                                                Namespace:      pod.Namespace,
                                                ValidationType: "dangling_configmap_volume",
                                                Message:        fmt.Sprintf("ConfigMap '%s' referenced in volume does not exist", configMapName),
                                        })
                                }</span>
                        }
                }

                // Check ConfigMap references in envFrom
                <span class="cov0" title="0">for _, container := range pod.Spec.Containers </span><span class="cov0" title="0">{
                        for _, envFrom := range container.EnvFrom </span><span class="cov0" title="0">{
                                if envFrom.ConfigMapRef != nil </span><span class="cov0" title="0">{
                                        configMapName := envFrom.ConfigMapRef.Name
                                        if err := v.validateConfigMapExists(ctx, configMapName, pod.Namespace); err != nil </span><span class="cov0" title="0">{
                                                errors = append(errors, ValidationError{
                                                        ResourceType:   "Pod",
                                                        ResourceName:   pod.Name,
                                                        Namespace:      pod.Namespace,
                                                        ValidationType: "dangling_configmap_envfrom",
                                                        Message:        fmt.Sprintf("ConfigMap '%s' referenced in envFrom does not exist", configMapName),
                                                })
                                        }</span>
                                }
                        }
                }
        }

        <span class="cov0" title="0">return errors, nil</span>
}

func (v *ReferenceValidator) validateConfigMapExists(ctx context.Context, name, namespace string) error <span class="cov0" title="0">{
        var configMap corev1.ConfigMap
        return v.client.Get(ctx, types.NamespacedName{
                Name:      name,
                Namespace: namespace,
        }, &amp;configMap)
}</span>

func (v *ReferenceValidator) validateSecretReferences(ctx context.Context) ([]ValidationError, error) <span class="cov0" title="0">{
        var errors []ValidationError

        // Get all Pods to check Secret references
        var pods corev1.PodList
        if err := v.client.List(ctx, &amp;pods); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list pods: %w", err)
        }</span>

        <span class="cov0" title="0">for _, pod := range pods.Items </span><span class="cov0" title="0">{
                // Check Secret references in volumes
                for _, volume := range pod.Spec.Volumes </span><span class="cov0" title="0">{
                        if volume.Secret != nil </span><span class="cov0" title="0">{
                                secretName := volume.Secret.SecretName
                                if err := v.validateSecretExists(ctx, secretName, pod.Namespace); err != nil </span><span class="cov0" title="0">{
                                        errors = append(errors, ValidationError{
                                                ResourceType:   "Pod",
                                                ResourceName:   pod.Name,
                                                Namespace:      pod.Namespace,
                                                ValidationType: "dangling_secret_volume",
                                                Message:        fmt.Sprintf("Secret '%s' referenced in volume does not exist", secretName),
                                        })
                                }</span>
                        }
                }

                // Check Secret references in envFrom and env
                <span class="cov0" title="0">for _, container := range pod.Spec.Containers </span><span class="cov0" title="0">{
                        for _, envFrom := range container.EnvFrom </span><span class="cov0" title="0">{
                                if envFrom.SecretRef != nil </span><span class="cov0" title="0">{
                                        secretName := envFrom.SecretRef.Name
                                        if err := v.validateSecretExists(ctx, secretName, pod.Namespace); err != nil </span><span class="cov0" title="0">{
                                                errors = append(errors, ValidationError{
                                                        ResourceType:   "Pod",
                                                        ResourceName:   pod.Name,
                                                        Namespace:      pod.Namespace,
                                                        ValidationType: "dangling_secret_envfrom",
                                                        Message:        fmt.Sprintf("Secret '%s' referenced in envFrom does not exist", secretName),
                                                })
                                        }</span>
                                }
                        }

                        <span class="cov0" title="0">for _, env := range container.Env </span><span class="cov0" title="0">{
                                if env.ValueFrom != nil &amp;&amp; env.ValueFrom.SecretKeyRef != nil </span><span class="cov0" title="0">{
                                        secretName := env.ValueFrom.SecretKeyRef.Name
                                        if err := v.validateSecretExists(ctx, secretName, pod.Namespace); err != nil </span><span class="cov0" title="0">{
                                                errors = append(errors, ValidationError{
                                                        ResourceType:   "Pod",
                                                        ResourceName:   pod.Name,
                                                        Namespace:      pod.Namespace,
                                                        ValidationType: "dangling_secret_env",
                                                        Message:        fmt.Sprintf("Secret '%s' referenced in env does not exist", secretName),
                                                })
                                        }</span>
                                }
                        }
                }
        }

        // Check Ingress TLS secrets
        <span class="cov0" title="0">var ingresses networkingv1.IngressList
        if err := v.client.List(ctx, &amp;ingresses); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list ingresses: %w", err)
        }</span>

        <span class="cov0" title="0">for _, ingress := range ingresses.Items </span><span class="cov0" title="0">{
                for _, tls := range ingress.Spec.TLS </span><span class="cov0" title="0">{
                        if tls.SecretName != "" </span><span class="cov0" title="0">{
                                if err := v.validateSecretExists(ctx, tls.SecretName, ingress.Namespace); err != nil </span><span class="cov0" title="0">{
                                        errors = append(errors, ValidationError{
                                                ResourceType:   "Ingress",
                                                ResourceName:   ingress.Name,
                                                Namespace:      ingress.Namespace,
                                                ValidationType: "dangling_tls_secret",
                                                Message:        fmt.Sprintf("TLS Secret '%s' referenced in Ingress does not exist", tls.SecretName),
                                        })
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">return errors, nil</span>
}

func (v *ReferenceValidator) validatePVCReferences(ctx context.Context) ([]ValidationError, error) <span class="cov0" title="0">{
        var errors []ValidationError

        // Get all PVCs to check StorageClass references
        var pvcs corev1.PersistentVolumeClaimList
        if err := v.client.List(ctx, &amp;pvcs); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list pvcs: %w", err)
        }</span>

        // Get all StorageClasses for validation
        <span class="cov0" title="0">var storageClasses storagev1.StorageClassList
        if err := v.client.List(ctx, &amp;storageClasses); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list storage classes: %w", err)
        }</span>

        // Build a map of existing StorageClass names
        <span class="cov0" title="0">existingClasses := make(map[string]bool)
        for _, sc := range storageClasses.Items </span><span class="cov0" title="0">{
                existingClasses[sc.Name] = true
        }</span>

        <span class="cov0" title="0">for _, pvc := range pvcs.Items </span><span class="cov0" title="0">{
                if pvc.Spec.StorageClassName != nil </span><span class="cov0" title="0">{
                        className := *pvc.Spec.StorageClassName
                        if !existingClasses[className] </span><span class="cov0" title="0">{
                                errors = append(errors, ValidationError{
                                        ResourceType:   "PersistentVolumeClaim",
                                        ResourceName:   pvc.Name,
                                        Namespace:      pvc.Namespace,
                                        ValidationType: "dangling_storage_class",
                                        Message:        fmt.Sprintf("StorageClass '%s' does not exist", className),
                                })
                        }</span>
                }
        }

        // Check Pod volumes referencing PVCs
        <span class="cov0" title="0">var pods corev1.PodList
        if err := v.client.List(ctx, &amp;pods); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list pods: %w", err)
        }</span>

        <span class="cov0" title="0">for _, pod := range pods.Items </span><span class="cov0" title="0">{
                for _, volume := range pod.Spec.Volumes </span><span class="cov0" title="0">{
                        if volume.PersistentVolumeClaim != nil </span><span class="cov0" title="0">{
                                pvcName := volume.PersistentVolumeClaim.ClaimName
                                if err := v.validatePVCExists(ctx, pvcName, pod.Namespace); err != nil </span><span class="cov0" title="0">{
                                        errors = append(errors, ValidationError{
                                                ResourceType:   "Pod",
                                                ResourceName:   pod.Name,
                                                Namespace:      pod.Namespace,
                                                ValidationType: "dangling_pvc_reference",
                                                Message:        fmt.Sprintf("PVC '%s' referenced in volume does not exist", pvcName),
                                        })
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">return errors, nil</span>
}

func (v *ReferenceValidator) validateServiceAccountReferences(ctx context.Context) ([]ValidationError, error) <span class="cov0" title="0">{
        var errors []ValidationError

        // Get all Pods to check ServiceAccount references
        var pods corev1.PodList
        if err := v.client.List(ctx, &amp;pods); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list pods: %w", err)
        }</span>

        <span class="cov0" title="0">for _, pod := range pods.Items </span><span class="cov0" title="0">{
                saName := pod.Spec.ServiceAccountName
                if saName == "" </span><span class="cov0" title="0">{
                        saName = "default"
                }</span>
                
                <span class="cov0" title="0">if err := v.validateServiceAccountExists(ctx, saName, pod.Namespace); err != nil </span><span class="cov0" title="0">{
                        errors = append(errors, ValidationError{
                                ResourceType:   "Pod",
                                ResourceName:   pod.Name,
                                Namespace:      pod.Namespace,
                                ValidationType: "dangling_service_account",
                                Message:        fmt.Sprintf("ServiceAccount '%s' does not exist", saName),
                        })
                }</span>
        }

        <span class="cov0" title="0">return errors, nil</span>
}

func (v *ReferenceValidator) validateSecretExists(ctx context.Context, name, namespace string) error <span class="cov0" title="0">{
        var secret corev1.Secret
        return v.client.Get(ctx, types.NamespacedName{
                Name:      name,
                Namespace: namespace,
        }, &amp;secret)
}</span>

func (v *ReferenceValidator) validatePVCExists(ctx context.Context, name, namespace string) error <span class="cov0" title="0">{
        var pvc corev1.PersistentVolumeClaim
        return v.client.Get(ctx, types.NamespacedName{
                Name:      name,
                Namespace: namespace,
        }, &amp;pvc)
}</span>

func (v *ReferenceValidator) validateServiceAccountExists(ctx context.Context, name, namespace string) error <span class="cov0" title="0">{
        var sa corev1.ServiceAccount
        return v.client.Get(ctx, types.NamespacedName{
                Name:      name,
                Namespace: namespace,
        }, &amp;sa)
}</pre>
		
		<pre class="file" id="file2" style="display: none">package main

import (
        "flag"
        "os"
        "time"

        "k8s.io/apimachinery/pkg/runtime"
        utilruntime "k8s.io/apimachinery/pkg/util/runtime"
        clientgoscheme "k8s.io/client-go/kubernetes/scheme"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/healthz"
        "sigs.k8s.io/controller-runtime/pkg/log/zap"
        "sigs.k8s.io/controller-runtime/pkg/metrics/server"

        "github.com/russ/kogaro/internal/controllers"
        "github.com/russ/kogaro/internal/validators"
)

var (
        scheme   = runtime.NewScheme()
        setupLog = ctrl.Log.WithName("setup")
)

func init() <span class="cov0" title="0">{
        utilruntime.Must(clientgoscheme.AddToScheme(scheme))
}</span>

func main() <span class="cov0" title="0">{
        var metricsAddr string
        var enableLeaderElection bool
        var probeAddr string
        var scanInterval time.Duration
        
        // Validation flags
        var enableIngressValidation bool
        var enableConfigMapValidation bool
        var enableSecretValidation bool
        var enablePVCValidation bool
        var enableServiceAccountValidation bool

        flag.StringVar(&amp;metricsAddr, "metrics-bind-address", ":8080", "The address the metric endpoint binds to.")
        flag.StringVar(&amp;probeAddr, "health-probe-bind-address", ":8081", "The address the probe endpoint binds to.")
        flag.BoolVar(&amp;enableLeaderElection, "leader-elect", false,
                "Enable leader election for controller manager. "+
                        "Enabling this will ensure there is only one active controller manager.")
        flag.DurationVar(&amp;scanInterval, "scan-interval", 5*time.Minute, "Interval between cluster scans for reference validation")
        
        // Validation configuration flags
        flag.BoolVar(&amp;enableIngressValidation, "enable-ingress-validation", true, "Enable validation of Ingress references (IngressClass, Services)")
        flag.BoolVar(&amp;enableConfigMapValidation, "enable-configmap-validation", true, "Enable validation of ConfigMap references in Pods")
        flag.BoolVar(&amp;enableSecretValidation, "enable-secret-validation", true, "Enable validation of Secret references (volumes, env, TLS)")
        flag.BoolVar(&amp;enablePVCValidation, "enable-pvc-validation", true, "Enable validation of PVC and StorageClass references")
        flag.BoolVar(&amp;enableServiceAccountValidation, "enable-serviceaccount-validation", false, "Enable validation of ServiceAccount references (may be noisy)")
        
        opts := zap.Options{
                Development: true,
        }
        opts.BindFlags(flag.CommandLine)
        flag.Parse()

        ctrl.SetLogger(zap.New(zap.UseFlagOptions(&amp;opts)))

        mgr, err := ctrl.NewManager(ctrl.GetConfigOrDie(), ctrl.Options{
                Scheme: scheme,
                Metrics: server.Options{
                        BindAddress: metricsAddr,
                },
                HealthProbeBindAddress: probeAddr,
                LeaderElection:         enableLeaderElection,
                LeaderElectionID:       "kogaro.io",
        })
        if err != nil </span><span class="cov0" title="0">{
                setupLog.Error(err, "unable to start manager")
                os.Exit(1)
        }</span>

        // Initialize the reference validator with configuration
        <span class="cov0" title="0">validationConfig := validators.ValidationConfig{
                EnableIngressValidation:        enableIngressValidation,
                EnableConfigMapValidation:      enableConfigMapValidation,
                EnableSecretValidation:         enableSecretValidation,
                EnablePVCValidation:           enablePVCValidation,
                EnableServiceAccountValidation: enableServiceAccountValidation,
        }
        validator := validators.NewReferenceValidator(mgr.GetClient(), setupLog, validationConfig)

        // Setup the reference validation controller
        if err = (&amp;controllers.ValidationController{
                Client:       mgr.GetClient(),
                Scheme:       mgr.GetScheme(),
                Log:          ctrl.Log.WithName("controllers").WithName("ValidationController"),
                Validator:    validator,
                ScanInterval: scanInterval,
        }).SetupWithManager(mgr); err != nil </span><span class="cov0" title="0">{
                setupLog.Error(err, "unable to create controller", "controller", "ValidationController")
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">if err := mgr.AddHealthzCheck("healthz", healthz.Ping); err != nil </span><span class="cov0" title="0">{
                setupLog.Error(err, "unable to set up health check")
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">if err := mgr.AddReadyzCheck("readyz", healthz.Ping); err != nil </span><span class="cov0" title="0">{
                setupLog.Error(err, "unable to set up ready check")
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">setupLog.Info("starting manager")
        if err := mgr.Start(ctrl.SetupSignalHandler()); err != nil </span><span class="cov0" title="0">{
                setupLog.Error(err, "problem running manager")
                os.Exit(1)
        }</span>
}</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
